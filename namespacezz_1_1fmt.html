<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>Zupply: zz::fmt Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">Zupply 0.0.1</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacezz.html">zz</a></li><li class="navelem"><a class="el" href="namespacezz_1_1fmt.html">fmt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">zz::fmt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for formatting functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b04b032108b815ad47f7d08a27f86f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a1b04b032108b815ad47f7d08a27f86f7">is_digit</a> (char c)</td></tr>
<tr class="memdesc:a1b04b032108b815ad47f7d08a27f86f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if is digit.  <a href="#a1b04b032108b815ad47f7d08a27f86f7">More...</a><br /></td></tr>
<tr class="separator:a1b04b032108b815ad47f7d08a27f86f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab07c998af4c831b46d9e03ec42c2246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#aab07c998af4c831b46d9e03ec42c2246">wild_card_match</a> (const char *str, const char *pattern)</td></tr>
<tr class="memdesc:aab07c998af4c831b46d9e03ec42c2246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match string with wildcard. Match string with wildcard pattern, '*' and '?' supported.  <a href="#aab07c998af4c831b46d9e03ec42c2246">More...</a><br /></td></tr>
<tr class="separator:aab07c998af4c831b46d9e03ec42c2246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a696df5aa35802e7321ddcb761e3560"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a6a696df5aa35802e7321ddcb761e3560">ltrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a6a696df5aa35802e7321ddcb761e3560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left trim whitespace.  <a href="#a6a696df5aa35802e7321ddcb761e3560">More...</a><br /></td></tr>
<tr class="separator:a6a696df5aa35802e7321ddcb761e3560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae323b1e59582ff9f34b0a0955485ca0c"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#ae323b1e59582ff9f34b0a0955485ca0c">rtrim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:ae323b1e59582ff9f34b0a0955485ca0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right trim whitespace.  <a href="#ae323b1e59582ff9f34b0a0955485ca0c">More...</a><br /></td></tr>
<tr class="separator:ae323b1e59582ff9f34b0a0955485ca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70703afea548a515f88a317cc7314d96"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a70703afea548a515f88a317cc7314d96">trim</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a70703afea548a515f88a317cc7314d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left and right trim whitespace.  <a href="#a70703afea548a515f88a317cc7314d96">More...</a><br /></td></tr>
<tr class="separator:a70703afea548a515f88a317cc7314d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb86ee84554c702edf61300c4d5b5a7"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a7fb86ee84554c702edf61300c4d5b5a7">lstrip</a> (std::string &amp;str, std::string what)</td></tr>
<tr class="memdesc:a7fb86ee84554c702edf61300c4d5b5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip specified sub-string from left. The strip will do strict check from left, even whitespace. This function will change string in-place.  <a href="#a7fb86ee84554c702edf61300c4d5b5a7">More...</a><br /></td></tr>
<tr class="separator:a7fb86ee84554c702edf61300c4d5b5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb773fd96d50116b6f5a13276ce38a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#aafbb773fd96d50116b6f5a13276ce38a">rstrip</a> (std::string &amp;str, std::string what)</td></tr>
<tr class="memdesc:aafbb773fd96d50116b6f5a13276ce38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip specified sub-string from right. The strip will do strict check from right, even whitespace. This function will change string in-place.  <a href="#aafbb773fd96d50116b6f5a13276ce38a">More...</a><br /></td></tr>
<tr class="separator:aafbb773fd96d50116b6f5a13276ce38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c107a8b39587f93473ccb87bb081ed8"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a6c107a8b39587f93473ccb87bb081ed8">rskip</a> (std::string &amp;str, std::string delim)</td></tr>
<tr class="memdesc:a6c107a8b39587f93473ccb87bb081ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip from right until delimiter string found. This function modify string in-place.  <a href="#a6c107a8b39587f93473ccb87bb081ed8">More...</a><br /></td></tr>
<tr class="separator:a6c107a8b39587f93473ccb87bb081ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6ff0b49b454b309e42be51e7aca772"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a9e6ff0b49b454b309e42be51e7aca772">split</a> (const std::string s, char delim= ' ')</td></tr>
<tr class="memdesc:a9e6ff0b49b454b309e42be51e7aca772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into parts with specified single char delimiter.  <a href="#a9e6ff0b49b454b309e42be51e7aca772">More...</a><br /></td></tr>
<tr class="separator:a9e6ff0b49b454b309e42be51e7aca772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4cfe8ff2493862e8c09b9d121aa281"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#adf4cfe8ff2493862e8c09b9d121aa281">split</a> (const std::string s, std::string delim)</td></tr>
<tr class="memdesc:adf4cfe8ff2493862e8c09b9d121aa281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into parts with specified string delimiter. The entire delimiter must be matched exactly.  <a href="#adf4cfe8ff2493862e8c09b9d121aa281">More...</a><br /></td></tr>
<tr class="separator:adf4cfe8ff2493862e8c09b9d121aa281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98db8fec918190d08655e4331f27a368"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a98db8fec918190d08655e4331f27a368">split_multi_delims</a> (const std::string s, std::string delims)</td></tr>
<tr class="memdesc:a98db8fec918190d08655e4331f27a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string into parts with multiple single char delimiter.  <a href="#a98db8fec918190d08655e4331f27a368">More...</a><br /></td></tr>
<tr class="separator:a98db8fec918190d08655e4331f27a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff8ac8260b4fe2880a6f4871c359c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a77ff8ac8260b4fe2880a6f4871c359c6">split_whitespace</a> (const std::string s)</td></tr>
<tr class="memdesc:a77ff8ac8260b4fe2880a6f4871c359c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special case to <a class="el" href="namespacezz_1_1fmt.html#a98db8fec918190d08655e4331f27a368" title="Split string into parts with multiple single char delimiter. ">split_multi_delims()</a>, split all whitespace.  <a href="#a77ff8ac8260b4fe2880a6f4871c359c6">More...</a><br /></td></tr>
<tr class="separator:a77ff8ac8260b4fe2880a6f4871c359c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7874798ce2f331a564d5c782a50b912"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#ad7874798ce2f331a564d5c782a50b912">split_first_occurance</a> (const std::string s, char delim)</td></tr>
<tr class="memdesc:ad7874798ce2f331a564d5c782a50b912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split string in two parts with specified delim.  <a href="#ad7874798ce2f331a564d5c782a50b912">More...</a><br /></td></tr>
<tr class="separator:ad7874798ce2f331a564d5c782a50b912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f3192af9854d4198c99189e3cd26bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a49f3192af9854d4198c99189e3cd26bc">erase_empty</a> (std::vector&lt; std::string &gt; &amp;vec)</td></tr>
<tr class="memdesc:a49f3192af9854d4198c99189e3cd26bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through vector and erase empty ones. Erase in-place in vector.  <a href="#a49f3192af9854d4198c99189e3cd26bc">More...</a><br /></td></tr>
<tr class="separator:a49f3192af9854d4198c99189e3cd26bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67f6aeff032e5fac394efc1bbc38c49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#ab67f6aeff032e5fac394efc1bbc38c49">join</a> (std::vector&lt; std::string &gt; elems, char delim)</td></tr>
<tr class="memdesc:ab67f6aeff032e5fac394efc1bbc38c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a std::vector of strings into a string with delimiters.  <a href="#ab67f6aeff032e5fac394efc1bbc38c49">More...</a><br /></td></tr>
<tr class="separator:ab67f6aeff032e5fac394efc1bbc38c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710ec43d7a070c2b4657762fe329be61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a710ec43d7a070c2b4657762fe329be61">starts_with</a> (const std::string &amp;str, const std::string &amp;start)</td></tr>
<tr class="memdesc:a710ec43d7a070c2b4657762fe329be61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if string starts with specified sub-string.  <a href="#a710ec43d7a070c2b4657762fe329be61">More...</a><br /></td></tr>
<tr class="separator:a710ec43d7a070c2b4657762fe329be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5058a94b7d7204feb091d1b85d43357a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a5058a94b7d7204feb091d1b85d43357a">ends_with</a> (const std::string &amp;str, const std::string &amp;end)</td></tr>
<tr class="memdesc:a5058a94b7d7204feb091d1b85d43357a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if string ends with specified sub-string.  <a href="#a5058a94b7d7204feb091d1b85d43357a">More...</a><br /></td></tr>
<tr class="separator:a5058a94b7d7204feb091d1b85d43357a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf147ecc7423e75fbf52d4ec610a9ad"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#aebf147ecc7423e75fbf52d4ec610a9ad">replace_all</a> (std::string &amp;str, char replaceWhat, char replaceWith)</td></tr>
<tr class="memdesc:aebf147ecc7423e75fbf52d4ec610a9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all from one to another sub-string, char version.  <a href="#aebf147ecc7423e75fbf52d4ec610a9ad">More...</a><br /></td></tr>
<tr class="separator:aebf147ecc7423e75fbf52d4ec610a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd5be4f5a2d7bf6e0570fe651387c36"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a1cd5be4f5a2d7bf6e0570fe651387c36">replace_all</a> (std::string &amp;str, const std::string &amp;replaceWhat, const std::string &amp;replaceWith)</td></tr>
<tr class="memdesc:a1cd5be4f5a2d7bf6e0570fe651387c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all from one to another sub-string.  <a href="#a1cd5be4f5a2d7bf6e0570fe651387c36">More...</a><br /></td></tr>
<tr class="separator:a1cd5be4f5a2d7bf6e0570fe651387c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1df6536572e970e65df9983703c69aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#ab1df6536572e970e65df9983703c69aa">replace_first_with_escape</a> (std::string &amp;str, const std::string &amp;replaceWhat, const std::string &amp;replaceWith)</td></tr>
<tr class="memdesc:ab1df6536572e970e65df9983703c69aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace first occurance of one string with specified another string. Replace in-place.  <a href="#ab1df6536572e970e65df9983703c69aa">More...</a><br /></td></tr>
<tr class="separator:ab1df6536572e970e65df9983703c69aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d73194973d3de063be8656feec92828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a3d73194973d3de063be8656feec92828">replace_all_with_escape</a> (std::string &amp;str, const std::string &amp;replaceWhat, const std::string &amp;replaceWith)</td></tr>
<tr class="memdesc:a3d73194973d3de063be8656feec92828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every occurance of one string with specified another string. Replace in-place.  <a href="#a3d73194973d3de063be8656feec92828">More...</a><br /></td></tr>
<tr class="separator:a3d73194973d3de063be8656feec92828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e74fec90695ac896a641a3c7d511af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#ad5e74fec90695ac896a641a3c7d511af">str_equals</a> (const char *s1, const char *s2)</td></tr>
<tr class="memdesc:ad5e74fec90695ac896a641a3c7d511af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare c style raw string Will take care of string not ends with '\0', which is unsafe using strcmp().  <a href="#ad5e74fec90695ac896a641a3c7d511af">More...</a><br /></td></tr>
<tr class="separator:ad5e74fec90695ac896a641a3c7d511af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5382877380a1e94628e20c9f2bcb7e35"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a5382877380a1e94628e20c9f2bcb7e35">to_lower_ascii</a> (std::string mixed)</td></tr>
<tr class="memdesc:a5382877380a1e94628e20c9f2bcb7e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to lower case. Support ASCII characters only. Unicode string will trigger undefined behavior.  <a href="#a5382877380a1e94628e20c9f2bcb7e35">More...</a><br /></td></tr>
<tr class="separator:a5382877380a1e94628e20c9f2bcb7e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045944b579192928454fca6fe6759a79"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a045944b579192928454fca6fe6759a79">to_upper_ascii</a> (std::string mixed)</td></tr>
<tr class="memdesc:a045944b579192928454fca6fe6759a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to upper case. Support ASCII characters only. Unicode string will trigger undefined behavior.  <a href="#a045944b579192928454fca6fe6759a79">More...</a><br /></td></tr>
<tr class="separator:a045944b579192928454fca6fe6759a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfa8aea7b6901dc83b93dc286cc9918"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a0bfa8aea7b6901dc83b93dc286cc9918">int_to_zero_pad_str</a> (int num, int length)</td></tr>
<tr class="memdesc:a0bfa8aea7b6901dc83b93dc286cc9918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert int to left zero padded string.  <a href="#a0bfa8aea7b6901dc83b93dc286cc9918">More...</a><br /></td></tr>
<tr class="separator:a0bfa8aea7b6901dc83b93dc286cc9918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50192d21d60a83af5d0afa7a1189a6f"><td class="memItemLeft" align="right" valign="top">std::u16string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#aa50192d21d60a83af5d0afa7a1189a6f">utf8_to_utf16</a> (std::string &amp;u8str)</td></tr>
<tr class="memdesc:aa50192d21d60a83af5d0afa7a1189a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ 11 UTF-8 string to UTF-16 string.  <a href="#aa50192d21d60a83af5d0afa7a1189a6f">More...</a><br /></td></tr>
<tr class="separator:aa50192d21d60a83af5d0afa7a1189a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef8462ec2c52c4be9e9a9667629ad89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a1ef8462ec2c52c4be9e9a9667629ad89">utf16_to_utf8</a> (std::u16string &amp;u16str)</td></tr>
<tr class="memdesc:a1ef8462ec2c52c4be9e9a9667629ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ 11 UTF-16 string to UTF-8 string.  <a href="#a1ef8462ec2c52c4be9e9a9667629ad89">More...</a><br /></td></tr>
<tr class="separator:a1ef8462ec2c52c4be9e9a9667629ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ff395869423c2fe98644d4f249c89c"><td class="memItemLeft" align="right" valign="top">std::u32string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a78ff395869423c2fe98644d4f249c89c">utf8_to_utf32</a> (std::string &amp;u8str)</td></tr>
<tr class="memdesc:a78ff395869423c2fe98644d4f249c89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ 11 UTF-8 string to UTF-32 string.  <a href="#a78ff395869423c2fe98644d4f249c89c">More...</a><br /></td></tr>
<tr class="separator:a78ff395869423c2fe98644d4f249c89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa875daf41e52961d02b4826ba56fb5d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#aa875daf41e52961d02b4826ba56fb5d3">utf32_to_utf8</a> (std::u32string &amp;u32str)</td></tr>
<tr class="memdesc:aa875daf41e52961d02b4826ba56fb5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ 11 UTF-32 string to UTF-8 string.  <a href="#aa875daf41e52961d02b4826ba56fb5d3">More...</a><br /></td></tr>
<tr class="separator:aa875daf41e52961d02b4826ba56fb5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5943c7e37c3676facf74b8393009059"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af5943c7e37c3676facf74b8393009059"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#af5943c7e37c3676facf74b8393009059">format_string</a> (std::string &amp;fmt, const Arg &amp;last)</td></tr>
<tr class="memdesc:af5943c7e37c3676facf74b8393009059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format function to replace each {} with templated type variable.  <a href="#af5943c7e37c3676facf74b8393009059">More...</a><br /></td></tr>
<tr class="separator:af5943c7e37c3676facf74b8393009059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586765c66b79b68e40d15add65e8afc2"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:a586765c66b79b68e40d15add65e8afc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacezz_1_1fmt.html#a586765c66b79b68e40d15add65e8afc2">format_string</a> (std::string &amp;fmt, const Arg &amp;current, const Args &amp;...more)</td></tr>
<tr class="memdesc:a586765c66b79b68e40d15add65e8afc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vairadic variable version of format function to replace each {} with templated type variable.  <a href="#a586765c66b79b68e40d15add65e8afc2">More...</a><br /></td></tr>
<tr class="separator:a586765c66b79b68e40d15add65e8afc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for formatting functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5058a94b7d7204feb091d1b85d43357a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zz::fmt::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if string ends with specified sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">end</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

</div>
</div>
<a class="anchor" id="a49f3192af9854d4198c99189e3cd26bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; zz::fmt::erase_empty </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through vector and erase empty ones. Erase in-place in vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clean vector with no empty elements. </dd></dl>

</div>
</div>
<a class="anchor" id="af5943c7e37c3676facf74b8393009059"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Arg &gt; inline void zz::fmt::format_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format function to replace each {} with templated type variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Original string with place-holder {} </td></tr>
    <tr><td class="paramname">last</td><td>The last variable in variadic template function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a586765c66b79b68e40d15add65e8afc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template&lt; typename Arg &gt; inline void zz::fmt::format_string </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>more</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vairadic variable version of format function to replace each {} with templated type variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>Original string with place-holder {} </td></tr>
    <tr><td class="paramname">current</td><td>The current variable to be converted </td></tr>
    <tr><td class="paramname">...</td><td>more Variadic variables to be templated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bfa8aea7b6901dc83b93dc286cc9918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::int_to_zero_pad_str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert int to left zero padded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Integer number </td></tr>
    <tr><td class="paramname">length</td><td>String length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero-padded string </dd></dl>

</div>
</div>
<a class="anchor" id="a1b04b032108b815ad47f7d08a27f86f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zz::fmt::is_digit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if is digit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab67f6aeff032e5fac394efc1bbc38c49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::join </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a std::vector of strings into a string with delimiters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elems</td><td></td></tr>
    <tr><td class="paramname">delim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Concatenated string </dd></dl>

</div>
</div>
<a class="anchor" id="a7fb86ee84554c702edf61300c4d5b5a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::lstrip </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip specified sub-string from left. The strip will do strict check from left, even whitespace. This function will change string in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Original string </td></tr>
    <tr><td class="paramname">what</td><td>What to be stripped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stripped string </dd></dl>

</div>
</div>
<a class="anchor" id="a6a696df5aa35802e7321ddcb761e3560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::ltrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left trim whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trimed string </dd></dl>

</div>
</div>
<a class="anchor" id="aebf147ecc7423e75fbf52d4ec610a9ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replaceWhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>replaceWith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all from one to another sub-string, char version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">replaceWhat</td><td></td></tr>
    <tr><td class="paramname">replaceWith</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified string </dd></dl>

</div>
</div>
<a class="anchor" id="a1cd5be4f5a2d7bf6e0570fe651387c36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all from one to another sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">replaceWhat</td><td></td></tr>
    <tr><td class="paramname">replaceWith</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified string </dd></dl>

</div>
</div>
<a class="anchor" id="a3d73194973d3de063be8656feec92828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zz::fmt::replace_all_with_escape </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every occurance of one string with specified another string. Replace in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">replaceWhat</td><td>What substring to be replaced. </td></tr>
    <tr><td class="paramname">replaceWith</td><td>What string to replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1df6536572e970e65df9983703c69aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zz::fmt::replace_first_with_escape </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replaceWith</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace first occurance of one string with specified another string. Replace in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">replaceWhat</td><td>What substring to be replaced. </td></tr>
    <tr><td class="paramname">replaceWith</td><td>What string to replace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c107a8b39587f93473ccb87bb081ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::rskip </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skip from right until delimiter string found. This function modify string in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">delim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Skipped string </dd></dl>

</div>
</div>
<a class="anchor" id="aafbb773fd96d50116b6f5a13276ce38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::rstrip </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip specified sub-string from right. The strip will do strict check from right, even whitespace. This function will change string in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Original string </td></tr>
    <tr><td class="paramname">what</td><td>What to be stripped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Stripped string </dd></dl>

</div>
</div>
<a class="anchor" id="ae323b1e59582ff9f34b0a0955485ca0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::rtrim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right trim whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trimed string </dd></dl>

</div>
</div>
<a class="anchor" id="a9e6ff0b49b454b309e42be51e7aca772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; zz::fmt::split </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into parts with specified single char delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">delim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of parts in std::string </dd></dl>

</div>
</div>
<a class="anchor" id="adf4cfe8ff2493862e8c09b9d121aa281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; zz::fmt::split </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into parts with specified string delimiter. The entire delimiter must be matched exactly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">delim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of parts in std::string </dd></dl>

</div>
</div>
<a class="anchor" id="ad7874798ce2f331a564d5c782a50b912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, std::string &gt; zz::fmt::split_first_occurance </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string in two parts with specified delim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">delim</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair of std::string, ret.first = first part, ret.second = second part </dd></dl>

</div>
</div>
<a class="anchor" id="a98db8fec918190d08655e4331f27a368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; zz::fmt::split_multi_delims </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split string into parts with multiple single char delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">delim</td><td>A std::string contains multiple single char delimiter, e.g.(' <br />
') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of parts in std::string </dd></dl>

</div>
</div>
<a class="anchor" id="a77ff8ac8260b4fe2880a6f4871c359c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; zz::fmt::split_whitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special case to <a class="el" href="namespacezz_1_1fmt.html#a98db8fec918190d08655e4331f27a368" title="Split string into parts with multiple single char delimiter. ">split_multi_delims()</a>, split all whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::vector of parts in std::string </dd></dl>

</div>
</div>
<a class="anchor" id="a710ec43d7a070c2b4657762fe329be61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zz::fmt::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if string starts with specified sub-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">start</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

</div>
</div>
<a class="anchor" id="ad5e74fec90695ac896a641a3c7d511af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zz::fmt::str_equals </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare c style raw string Will take care of string not ends with '\0', which is unsafe using strcmp(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td></td></tr>
    <tr><td class="paramname">s2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if same </dd></dl>

</div>
</div>
<a class="anchor" id="a5382877380a1e94628e20c9f2bcb7e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::to_lower_ascii </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mixed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to lower case. Support ASCII characters only. Unicode string will trigger undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixed</td><td>Mixed case string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lower case string. </dd></dl>

</div>
</div>
<a class="anchor" id="a045944b579192928454fca6fe6759a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::to_upper_ascii </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>mixed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to upper case. Support ASCII characters only. Unicode string will trigger undefined behavior. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixed</td><td>Mixed case string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Upper case string. </dd></dl>

</div>
</div>
<a class="anchor" id="a70703afea548a515f88a317cc7314d96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; zz::fmt::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left and right trim whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trimed string </dd></dl>

</div>
</div>
<a class="anchor" id="a1ef8462ec2c52c4be9e9a9667629ad89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::utf16_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">std::u16string &amp;&#160;</td>
          <td class="paramname"><em>u16str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ 11 UTF-16 string to UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16str</td><td>UTF-16 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 string </dd></dl>

</div>
</div>
<a class="anchor" id="aa875daf41e52961d02b4826ba56fb5d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string zz::fmt::utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">std::u32string &amp;&#160;</td>
          <td class="paramname"><em>u32str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ 11 UTF-32 string to UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u32str</td><td>UTF-32 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-8 string </dd></dl>

</div>
</div>
<a class="anchor" id="aa50192d21d60a83af5d0afa7a1189a6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::u16string zz::fmt::utf8_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>u8str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ 11 UTF-8 string to UTF-16 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u8str</td><td>UTF-8 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-16 string </dd></dl>

</div>
</div>
<a class="anchor" id="a78ff395869423c2fe98644d4f249c89c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::u32string zz::fmt::utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>u8str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>C++ 11 UTF-8 string to UTF-32 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u8str</td><td>UTF-8 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UTF-32 string </dd></dl>

</div>
</div>
<a class="anchor" id="aab07c998af4c831b46d9e03ec42c2246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool zz::fmt::wild_card_match </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Match string with wildcard. Match string with wildcard pattern, '*' and '?' supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">pattern</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for success match </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 2 2015 15:46:01 for Zupply by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
